#pragma once
/***
=== 动态多态
基类对象的指针或基类对象的引用
实现多态
根据传入的子类对象而决定调用 子类特定的虚函数
如果虚函数在子类有实现,调用子类实现的虚函数
否则, 调用的是父类的虚函数
 
1. 调用的函数在基类中必须为虚函数
2. 通过 基类对象的指针或基类对象的引用来调用
 
===虚函数 与 纯虚函数
子类 继承 虚函数,可以实现,也可以不实现,不影响实例化
virtual void work();
 
子类 继承 纯虚函数,只有实现后才能实例化
virtual double income() = 0;
 
抽象基类ABC:abstrac base class
包含有pure virtual 纯虚函数, 不能实例成对象
纯虚函数类似接口(标准)
 
在使用继承的时候，子类必然是在父类的基础上有所改变。如果两者完全相同，这样的
继承就失去了意义。同时，不同子类之间具体实现也是有所区别的，否则就出现了一个多余的类。 不同的类的同名成员函数有着不同的表现形式，称为多态性。多态性是符合人的认知规律的，即称呼相同，所指不同。 比如，学生类及其子类都有学习这个成员函数，但本
科生、中学生、小学生的学习内容并不相同；玩家类的子类都有攻击这项技能，但剑士、弓
箭手和魔法师的攻击方法不同。
 
多态性往往只有在使用对象指针或对象引用时才体现出来。 编译器在编译程序的时候完全不知道对象指针可能会指向哪种对象（引用也是类似的情况），只有到程序运行了之后
才能明确指针访问的成员函数是属于哪个类的。我们把 C++的这种功能称为“滞后联编”。
多态性是面向对象的一个标志性特点，没有这个特点，就无法称为面向对象。
 
用来抽象相关类的共性.
需求: 计算职工的工资.学校职员(行政人员,实验人员,教师,工作人员...)
 
抽象基类:包含至少一个纯虚函数的类,该类不能实例化对象 
约束 其派生类必须实现某些指定的方法,这些方法就是 纯虚函数
其作用相当于接口
在C++是没有接口,接口的作用就由抽象基类来实现
 
*/
 
/*职工类:抽象基类
*/
#include "comm.h"
 
class WorkerABC
{
public:
//成员函数
void study();
 
//虚函数
virtual void work();
 
//纯虚函数:声明=0; 函数没有定义实现
virtual double income()=0;
 
WorkerABC(void);
~WorkerABC(void);
};

